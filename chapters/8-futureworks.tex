\chapter{Future works}
\label{sec:future}
We believe there is a deep connections between \egraphs and relational dabase and \egraph can really benefit from research fruits of the database community. This thesis is only a very first attempt to bridging \egraphs and relational databases. Many things are left to be done. This sections sketches a few future works that are worth investigating. Some of them are technical, while others require insights into both areas.

\paragraph{Experiments.}
The current experiments are still very preliminary. To fully explore the design space of various join algorithms (e.g., hash join, Yannarakis' join algorithm) and query optimization strategies (e.g., different variable ordering for generic join, as well as standard optimization techniques for relational queries) for the scenarios of \ematching.

\paragraph{Multi-patterns.} A common extension to \ematching is multi-patterns \citep{efficient-ematching}. Multi-patterns generalize single patterns to multiple patterns that share the the same of variables. For example, $\alpha \times \beta, \alpha\times \gamma$ is a multi-pattern that searches for substitutions $\sigma$ that satisfy $\sigma(\alpha\times\beta)$ and $\sigma(\alpha\times\gamma)$ are both present simultaneously. They are extensively used in SMT solvers and are also useful in various equality saturation scenarios. Specialized algorithms are developed for multi-patterns. However, from a relational perspective, the CQ generated by a multi-pattern is just a sequence of CQ atoms generated from each pattern placed together. Therefore, the relational \ematching naturally generalizes to the scenarios of multi-patterns.

\paragraph{Optimizing query plans for generic joins.} There are not as many research done on optimizing the variable ordering as on optimizing traditional join plans. EmptyHeaded is the first graph database engine that uses generalized hypertree decompositions (GHD) to optimize generic join and achieves performance similar to low-level graph engines. However, it only focuses achieves a stronger run-time worst-case optimality guarantee, but does not take variable ordering into considerations. Yet it has been shown different variable ordering may leads to asymptotically different results \citep{eval-wcoj}. Therefore, it is one of our future directions to design algorithms to search for an optimal variable orderings during query optimization.

\paragraph{\Egraph engine purely on relational databases.} This paper only exploits the possibility of doing \ematching on a relational representation of \egraphs. It is our assumption that normal \egraph operations like merge and lookup are still done on the original \egraph representation and the relational representation will be re-computed during each (batch of) \ematching.   However, it is possible to build an \egraph engine purely on top of relational databases by canonicalizing every \enode on the fly during merge. Although we expect it incurs performance penalty to use a purely relational database to describe \egraph and operations on \egraph, it is ideal for situations where interactive \ematching is required. In such cases, it is unrealistic to rebuild the relational representation for every \ematching invocation, while such cost can be avoided if all \egraph operations are directly applied to its relational representation. Moreover, by describing every \ematching operations in terms of the language of relational databases, it is possible to benefit from the literature on incremental maintenance of relational databases and design an algorithm for {\it incremental} \ematching.

\paragraph{Exploring functional dependency for relational \ematching.} Functional dependencies are constraints such as two atoms having the same value on attributes $\textit{attr}_1,\ldots \textit{attr}_{n-1}$ implies they also share the same value on attribute $\textit{attr}_n$. Functional dependency are ubiquitous in relational databases, and they are also present in the relational representation of \egraphs. In particular, For a relation $R_f(\textit{eclass-id},\child_1,\ldots,\child_k)$ representing $f$, the value of $\textit{eclass-id}$ are determined by the values of $\child_1,\ldots \child_k$.

Our current relational \ematching does not take functional dependencies into considerations, but they may have an impact on the bound of worst-case output. Fortunately, there are worst-case optimal join algorithms that guarantee optimality with the presence of functional dependencies. Therefore, it is worth incorporating functional dependencies into relational \ematching and derives a tighter worst-case bound for relational \ematching.

\paragraph{Datalog engine with internalized congruence.} 
One of our initial motivation for this work is to develop a more flexible language for \egg. Tasks in \egg are described as rewrite rules that add the rewritten terms into the same \eclass as the matched terms. Therefore, \egg only supports equivalence reasoning, and it is very hard to describe relations that are not symmetric, such as a transitive closure. However, such directed relations are prevalent in real-world applications. One idea is to make the \egraph engine an extension of the Datalog language \citep{datalog-survey}. Datalog is a logic programming language that can be efficiently evaluated, and many relational properties such as transitivity, reflexivity, and symmetry can be naturally expressed in Datalog.
However, many relations, such as the equivalence relation, may be asymptotically slower if directly expressed in Datalog compared to a dedicated data structure.
Souffl\'e is a Datalog tool that support efficient equivalence relations as a specialized relation and uses an efficient union-find data structure to maintain equivalence relations.
Therefore, it is desired to extend Datalog language to efficient maintain congruence closures. On the one hand, this extends the equivalence reasoning in \egraphs to other kinds of reasoning as well. On the other hand, it makes certain existing Datalog programs efficient by using a more dedicated data structure.
