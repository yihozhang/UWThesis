\chapter{Conclusion}

Existing \ematching algorithms are based on backtracking and suffer from problems like implementation difficulty, run inefficiency, and a loose complexity bound. To tackle these problems, we propose relational \ematching, an algorithm that efficiently solves the \ematching problem by reducing it to conjunctive queries. Relational \ematching is based on the observation that \ematching is definitionally similar to conjunctive queries. Leveraging this observation, relational \ematching maps an \egraph to a set of relations and compiles every \ematching pattern to a conjunctive query. As conjunctive query has been extensively studied in the database community for decades, relational \ematching is \textit{conceptually simpler}. Moreover, such relational representation provides an unified way to express not only structural constraints, but also equality constraints, which are constraints that backtracking-based \ematching fails to take advantage of during query planning. By exploiting equality constraints, relational \ematching performs \textit{asymptotically faster }than existing\ematching algorithms on many queries. Finally, to avoid enumerate an unnecessarily large space of candidates, relational \ematching uses generic join to solve the generated conjunctive queries, which makes relational \ematching \textit{worst-case optimal}.

We implemented relational \ematching in \egg and evaluate our relational \ematching on some microbenchmarks. Preliminary experiment indicates that relational \ematching shows asymptotic speedup over backtracking-based \ematching algorithms on both cyclic and nonlinear acyclic patterns. However, for linear patterns, relational \ematching shows similar performance as backtracking-based \ematching algorithms, up to a constant factor. In the future, we plan to evaluate relational \ematching more extensively and on more realistic \egraph applications.